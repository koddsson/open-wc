<!doctype html>
<html>
  <head>
    <script type="module">
      import { ContextEvent, createContext } from '../index.ts';

      class ObservableMap {
        constructor() {
          this.store = new Map();
        }

        set(key, value, subscribers = new Set()) {
          const data = this.store.get(key);
          subscribers = new Set([...subscribers, ...(data?.subscribers || new Set())]);
          this.store.set(key, {value, subscribers});
          for (const subscriber of subscribers) {
            subscriber(value);
          }
        }

        get(key) {
          return this.store.get(key);
        }
      }

      window.customElements.define('server-state', class ServerState extends HTMLElement {
        dataStore = new ObservableMap();
        connectedCallback() {
          // We listen for a bubbled context request event and provide the event with the context requested.
          this.addEventListener('context-request', event => {
            const {name, initialValue} = event.context;
            const subscribe = event.subscribe;
            if (initialValue) {
              this.dataStore.set(name, initialValue);
            }
            const data = this.dataStore.get(name);
            if (data) {
              event.stopPropagation();

              let unsubscribe;

              if (subscribe) {
                unsubscribe = () => { data.subscribes.remove(event.callback) }
                data.subscribers.add(event.callback);
              }

              event.callback(data.value, unsubscribe);
            }
          });
        }
      });

      window.customElements.define('hit-count', class HitCount extends HTMLElement {
        connectedCallback() {
          // This component would like `hit-count` so we create that context.
          const context = createContext('hit-count', 9001);

          // We dispatch a event with that context. The event will bubble up the tree until it
          // reaches a component that is able to provide that value to us.
          // The event has a callback for the the value.
          this.dispatchEvent(new ContextEvent(
            context,
            (count, unsubscribe) => {
              this.textContent = `${count} hits!`;
              this.unsubscribe = unsubscribe;
            },
            true
          ));
        }

        disconnectedCallback() {
          this.unsubscribe?.();
          this.unsubscribe = undefined;
        }
      });
    </script>
  </head>
  <body>
    <server-state>
      <hit-count>
        Loading...
      </hit-count>
    </server-state>

    <script type="module">
      import { runTests } from "@web/test-runner-mocha";
      import { expect } from "chai";
      import { waitUntil } from '@open-wc/testing';

      runTests(() => {
        it("subscribes to changes", async () => {
          const provider = document.querySelector('server-state');
          const el = document.querySelector('hit-count');
          await waitUntil(() => el.textContent.trim() !== 'Loading...');
          expect(el.textContent).to.equal('9001 hits!');
         
          provider.dataStore.set('hit-count', 9002);
          await waitUntil(() => el.textContent.trim() !== '9001 hits!');
          expect(el.textContent).to.equal('9002 hits!');
        });
      });
    </script>
  </body>
</html>
